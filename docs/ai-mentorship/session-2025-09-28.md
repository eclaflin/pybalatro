# AI Mentorship Summary: pybalatro Design Session
*Date range: 2025-09-28 – 2025-09-29*

## 1. Purpose
This document summarizes the guided mentorship discussion that shaped the high-level architecture of `pybalatro`. The focus is on the **dialogue of questions and reasoning** between myself and an AI acting as a senior developer mentor. The goal was to highlight critical thinking, design exploration, and decision-making — not to generate finished code.  

---

## 2. Mentorship Log: Questions & Reasoning

### 2.1 High-Level Design
- **Mentor Question:** “If you were to start at the highest level, how would you structure the system?”  
- **My Reasoning:** I wanted to focus on OOP and data, not GUI, so CLI was sufficient. I identified `Card` as a first-class object, followed by `Joker` and `Consumable`, with `Deck` and `Hand` as collections.

- **Mentor Question:** “Where should scoring logic live — inside objects or centralized?”  
- **My Reasoning:** Centralizing the scoring engine made sense because individual objects (like Jokers) would need to know too much about other objects if they scored themselves. This simplified state management and sequencing.

### 2.2 Object Responsibilities
- **Mentor Question:** “How do you think about the complexity of Joker effects?”  
- **My Reasoning:** Some Jokers are complex enough that encoding them as simple rules could create convoluted nested logic. I concluded that a unique method per Joker would allow extensibility long-term, while still letting the engine orchestrate sequencing.

- **Mentor Question:** “How do you define the scope of what a round or ‘active play’ sees?”  
- **My Reasoning:** I defined `ActivePlay` as a snapshot of the current state: the 5+ Joker slots, 2+ Consumable slots, and cards in play. This limits the state any scoring function needs to consider.

### 2.3 Sequencing and Orchestration
- **Mentor Question:** “Who should control the sequence of effect evaluation?”  
- **My Reasoning:** Centralized in the scoring engine. Deterministic order matters: cards → Jokers → Consumables. Letting objects control sequencing adds flexibility but sacrifices maintainability.

- **Mentor Question:** “Should the game loop be a method or an object?”  
- **My Reasoning:** Using a `Round` or `Game` class allows encapsulation of the round state and makes methods more testable. A big function would become hard to maintain.

- **Mentor Question:** “Which responsibilities stay in the orchestrator vs. scoring engine vs. objects?”  
- **My Reasoning:** Orchestrator handles loop and sequencing, engine handles calculation of deltas, objects provide their effect logic but do not manage global state.

### 2.4 Design Trade-offs
- **Mentor Question:** “How do you balance flexibility vs. extensibility?”  
- **My Reasoning:** Cards are dumb; Jokers/Consumables encapsulate effect logic; scoring engine centralizes sequencing. This minimizes nested conditional complexity while allowing new effect types to be added without changing engine logic.

- **Mentor Question:** “How do you structure state so it’s manageable for computation?”  
- **My Reasoning:** `ActivePlay` holds only what’s needed for scoring the current round. The engine updates running totals, multipliers, and other outcomes as it evaluates objects.

---

## 3. Key Insights from the Mentorship
1. Centralizing complex logic in the engine reduces tangled state dependencies.  
2. Encapsulation of object-specific effects preserves extensibility.  
3. A small, well-defined snapshot of state (`ActivePlay`) simplifies calculations.  
4. Deterministic sequencing is critical for maintainable game logic.  
5. Using a class for the round/game loop improves testability and structure.  

---

## 4. Next Steps
- Begin implementation with project skeleton (`pybalatro/`, `tests/`, `docs/`)  
- Implement `Card`, `Joker`, `Consumable`, and `ActivePlay` classes  
- Build a scoring engine skeleton that applies effects in sequence  
- Document ongoing decisions in devlogs and AI mentorship logs
