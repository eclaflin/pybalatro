# Devlog: 2025-09-28
*Project: pybalatro*

## 1. Goals for this session
- Think through high-level system design for a Balatro clone.
- Focus on object-oriented modeling and data management.
- Avoid UI/GUI — CLI or no interface is fine.
- Start laying the foundation for architecture documentation.

## 2. Work completed
- Identified **core entities** for OOP:
  - `Card` as the primary class
  - `Joker` and `Consumable` as effect-bearing objects
  - `Deck` and `Hand` as collection classes
- Discussed **scoring engine** design:
  - Centralized engine to evaluate hands
  - Cards are dumb objects; scoring logic lives externally
  - Jokers/Consumables encapsulate their own effect logic (`apply_effect`)
  - Engine reads effects and updates `ActivePlay`
- Scoped **state management**:
  - Defined `ActivePlay` as snapshot of game state (slots, running totals, cards in play)
  - Effects operate on limited, relevant parts of the board to keep logic manageable
- Discussed **effect sequencing**:
  - Deterministic order: cards → Jokers → Consumables
  - Scoring engine orchestrates sequencing, rather than objects themselves
- Considered **game loop / orchestration**:
  - Loop structured around rounds (blind)
  - Loop continues until player busts or clears the blind
  - Dedicated `Round` or `Game` class likely orchestrates loop
- Clarified **extensibility trade-offs**:
  - Jokers/Consumables encapsulate unique effect logic
  - Centralized scoring engine ensures deterministic behavior
  - `ActivePlay` remains the owner of state snapshot

## 3. Decisions made / design notes
- Keep cards as simple data holders; behavior is centralized.
- Jokers and Consumables have their own methods for applying effects (`apply_effect(active_play_state)`), returning a dictionary of deltas.
- Scoring engine updates `ActivePlay` based on those deltas.
- Centralize sequencing to avoid distributed state management issues.
- Game loop handled by an orchestrator class (`Round`/`Game`) for maintainability and extensibility.

## 4. Challenges / blockers
- Balancing centralized engine vs. object-level behavior for Jokers and Consumables.
- Ensuring effects don’t conflict or require each object to know global game state.
- Deciding scope of `ActivePlay` to include only relevant slots and cards.

## 5. Next steps / todo
- Write initial Python package skeleton:
  - `__init__.py`, `cards.py`, `deck.py`, `scoring_engine.py`
  - Set up project structure with `docs/`, `tests/`, and `pyproject.toml`
- Define initial `Card`, `Joker`, and `Consumable` classes with basic attributes.
- Implement `ActivePlay` class to hold snapshot state.
- Draft starter README and devlog templates for ongoing documentation.

## 6. Misc notes / ideas
- Repository name chosen: `pybalatro`
- Consider linking devlog entries to GitHub commits for traceability.
- Each dev session can be a separate `.md` file in `docs/devlog/`.

## 7. AI Mentorship
- [Logs](../ai-mentorship/session-2025-09-28.md)