# Devlog: 2025-10-06
*Project: pybalatro*

## 1. Goals for this session
- Implement a `Deck` class to act as a container of `Card` objects
- Implement a `DeckFactory` class to generate a standard 52-card deck using the existing `Card` class.
- Write initial unit tests with `pytest` to validate `Card` creation and deck generation (including invalid input cases).
- Add lightweight logging or print statements to verify deck composition and debug object representations.

## 2. Work completed
- Created `DeckFactory` to define static methods used to create different types of decks
- Wrote first pytest to assert approach to creating valid `Card` objects

## 3. Decisions made / design notes
- `Deck` as a container class, `DeckFactory` as a factory object
  - Learned more about the factory design pattern [here](https://realpython.com/factory-method-python/?utm_source=chatgpt.com)
- Test decisions
  - Test that Card raises a ValueError if I try to create it using a suit or a face that's not included in it's acceptable class-level constants
  - Test that Deck only contains Card objects
  - Test that DeckFactory returns a deck of the appropriate length

## 4. Challenges / blockers
- Understanding `@staticmethod` decorator
  - In a nutshell, it doesn't rely on an instance of the class having already been created to run the method that belongs to the namespace of the class


## 5. Next steps / todo
- Continue building on pytest for deck and deckfactory

## 6. Misc notes / ideas


## 7. AI Mentorship

### Questions
- How should a DeckFactory relate to a Deck object? Are factories and container objects mutually exclusive, or can they be complementary?
- Does a static method make sense for deck generation if it doesn’t rely on instance attributes?
- How do @staticmethod and @classmethod differ in Python, and when would each be appropriate for factory-style creation?
- How should tests be structured to validate the factory behavior without duplicating all Card tests?

### Reasoning

- Factories are builders that encapsulate object creation logic; DeckFactory handles how a deck is built, while Deck handles what the deck does once it exists.
- A @staticmethod is appropriate for methods that don’t rely on self; such methods can be called directly on the class rather than an instance.
- The “missing self” error in Python often indicates either an unrecognized staticmethod decorator or a stale module import — in this case, a reload fixed the issue.
- Testing strategy:
  - Card unit tests validate core attributes and exception handling.
  - Deck tests focus on container-level behavior (length, types, draw/shuffle).
  - DeckFactory tests focus on creation logic (deck length, card validity, variations), relying on the assumption that Card is already correct.
- Using fixtures or parameterization in pytest can reduce repetition when testing multiple invalid or valid cases.